//! # Delta Circuit - Homomorphic Transaction Deltas
//!
//! This module implements the Δθ circuit that computes δ(tx) vectors for
//! homomorphic updates: ε_θ(S_{t+1}) = ε_θ(S_t) + δ(tx) with ≤1e-9 error.
//!
//! ## Key Functions:
//! 1. Compute δ(tx) for individual transfers
//! 2. Batch aggregation: Δ_B = Σ δ(tx_i)
//! 3. Verify δ(tx) consistency with encoder weights
//! 4. Generate succinct proofs for delta validity
//!
//! ## Mathematical Formulation:
//! For transfer tx = (sender, receiver, amount):
//! δ(tx) = amount × (emb_receiver - emb_sender) + bias_terms
//!
//! Where emb_sender, emb_receiver are learned account embeddings
//! from the transformer's token embedding layer.


use halo2_proofs::{
    circuit::{Layouter, SimpleFloorPlanner, Value},
    plonk::{Advice, Circuit, Column, ConstraintSystem, Error, Fixed, Instance},
    poly::Rotation,
};
use pasta_curves::pallas;
use std::marker::PhantomData;


use super::{
    NervCircuit, NervCircuitParams, CircuitWitness, CircuitPublicInputs,
    CircuitResult, CircuitError, FixedPoint32_16, Transaction,
};


/// Configuration for the Delta circuit
#[derive(Clone, Debug)]
pub struct DeltaConfig {
    /// Main parameters
    pub params: NervCircuitParams,
    
    /// Circuit columns
    pub instance: Column<Instance>,
    pub advice: [Column<Advice>; 8],
    pub fixed: [Column<Fixed>; 4],
    
    /// Specialized columns for account embeddings
    pub sender_embed_col: Column<Advice>,
    pub receiver_embed_col: Column<Advice>,
    pub amount_col: Column<Advice>,
    pub delta_col: Column<Advice>,
}


/// Parameters for delta computation
#[derive(Clone, Debug)]
pub struct DeltaParams {
    /// Account embedding matrix (num_accounts × 512)
    pub account_embeddings: Vec<Vec<FixedPoint32_16>>,
    
    /// Bias terms for transfer operation
    pub transfer_bias: Vec<FixedPoint32_16>,
    
    /// Scaling factors for amount encoding
    pub amount_scaling: FixedPoint32_16,
    
    /// Maximum batch size (256)
    pub max_batch_size: usize,
}


/// Delta circuit structure
#[derive(Clone, Debug)]
pub struct DeltaCircuit {
    /// Circuit configuration
    config: DeltaConfig,
    
    /// Delta computation parameters
    delta_params: DeltaParams,
    
    /// Transactions to process
    transactions: Vec<Transaction>,
    
    /// Phantom data for the field
    _marker: PhantomData<pallas::Base>,
}


/// Proof generated by Delta circuit
#[derive(Clone, Debug)]
pub struct DeltaProof {
    /// The computed delta vector (512 elements)
    pub delta: Vec<FixedPoint32_16>,
    
    /// Batch size
    pub batch_size: usize,
    
    /// Total amount transferred in batch
    pub total_amount: FixedPoint32_16,
    
    /// Proof bytes
    pub proof: Vec<u8>,
    
    /// Constraint count
    pub constraint_count: usize,
}


impl DeltaCircuit {
    /// Create a new Delta circuit
    pub fn new(
        config: DeltaConfig,
        delta_params: DeltaParams,
        transactions: Vec<Transaction>,
    ) -> Self {
        Self {
            config,
            delta_params,
            transactions,
            _marker: PhantomData,
        }
    }
    
    /// Configure the Delta circuit
    pub fn configure(cs: &mut ConstraintSystem<pallas::Base>) -> DeltaConfig {
        let params = NervCircuitParams::default();
        
        // Create columns
        let instance = cs.instance_column();
        let advice = [
            cs.advice_column(),
            cs.advice_column(),
            cs.advice_column(),
            cs.advice_column(),
            cs.advice_column(),
            cs.advice_column(),
            cs.advice_column(),
            cs.advice_column(),
        ];
        let fixed = [
            cs.fixed_column(),
            cs.fixed_column(),
            cs.fixed_column(),
            cs.fixed_column(),
        ];
        
        // Specialized columns for delta computation
        let sender_embed_col = cs.advice_column();
        let receiver_embed_col = cs.advice_column();
        let amount_col = cs.advice_column();
        let delta_col = cs.advice_column();
        
        // Enable equality constraints
        for col in &advice {
            cs.enable_equality(*col);
        }
        for col in &fixed {
            cs.enable_equality(*col);
        }
        
        // Define delta computation gates
        Self::define_delta_gates(
            cs,
            sender_embed_col,
            receiver_embed_col,
            amount_col,
            delta_col,
        );
        
        DeltaConfig {
            params,
            instance,
            advice,
            fixed,
            sender_embed_col,
            receiver_embed_col,
            amount_col,
            delta_col,
        }
    }
    
    /// Define gates for delta computation
    fn define_delta_gates(
        cs: &mut ConstraintSystem<pallas::Base>,
        sender_embed: Column<Advice>,
        receiver_embed: Column<Advice>,
        amount: Column<Advice>,
        delta: Column<Advice>,
    ) {
        // Delta computation gate: delta = amount × (receiver - sender)
        cs.create_gate("delta_computation", |vc| {
            let s = vc.query_advice(sender_embed, Rotation::cur());
            let r = vc.query_advice(receiver_embed, Rotation::cur());
            let a = vc.query_advice(amount, Rotation::cur());
            let d = vc.query_advice(delta, Rotation::cur());
            
            // d = a * (r - s)
            vec![d - a * (r - s)]
        });
        
        // Batch aggregation gate (accumulates deltas)
        cs.create_gate("batch_aggregation", |vc| {
            let delta_in = vc.query_advice(delta, Rotation::cur());
            let accum_in = vc.query_advice(delta, Rotation::prev());
            let accum_out = vc.query_advice(delta, Rotation::next());
            
            // accum_out = accum_in + delta_in
            vec![accum_out - (accum_in + delta_in)]
        });
    }
    
    /// Look up account embedding in the parameter table
    fn lookup_account_embedding(
        &self,
        account_key: &[u8; 32],
    ) -> Option<Vec<FixedPoint32_16>> {
        // In a real implementation, this would perform a lookup in the
        // account_embeddings table using the blinded key
        
        // For now, generate a deterministic embedding based on the key
        let mut embedding = Vec::with_capacity(512);
        let key_hash = blake3::hash(account_key);
        
        for i in 0..512 {
            let byte = key_hash.as_bytes()[i % 32];
            let value = (byte as f64 / 255.0) * 2.0 - 1.0; // Normalize to [-1, 1]
            embedding.push(FixedPoint32_16::from_float(value));
        }
        
        Some(embedding)
    }
    
    /// Compute delta for a single transaction
    pub fn compute_single_delta(
        &self,
        tx: &Transaction,
    ) -> CircuitResult<Vec<FixedPoint32_16>> {
        let dim = self.config.params.encoder_dim;
        
        // Look up sender and receiver embeddings
        let sender_embed = self.lookup_account_embedding(&tx.sender)
            .ok_or_else(|| CircuitError::WitnessGeneration("Sender embedding not found".into()))?;
        
        let receiver_embed = self.lookup_account_embedding(&tx.receiver)
            .ok_or_else(|| CircuitError::WitnessGeneration("Receiver embedding not found".into()))?;
        
        // Ensure embeddings have correct dimension
        if sender_embed.len() != dim || receiver_embed.len() != dim {
            return Err(CircuitError::DimensionMismatch(dim, sender_embed.len()));
        }
        
        // Compute delta: amount × (receiver - sender) + bias
        let mut delta = Vec::with_capacity(dim);
        
        for i in 0..dim {
            let receiver_val = receiver_embed[i];
            let sender_val = sender_embed[i];
            let bias = self.delta_params.transfer_bias.get(i)
                .copied()
                .unwrap_or(FixedPoint32_16::from_float(0.0));
            
            // delta_i = amount × (receiver_i - sender_i) + bias_i
            let diff = receiver_val.add(FixedPoint32_16::from_float(-1.0).mul(sender_val));
            let scaled = tx.amount.mul(diff);
            let final_val = scaled.add(bias);
            
            delta.push(final_val);
        }
        
        Ok(delta)
    }
    
    /// Compute aggregated delta for a batch
    pub fn compute_batch_delta(&self) -> CircuitResult<Vec<FixedPoint32_16>> {
        let dim = self.config.params.encoder_dim;
        
        // Check batch size limit
        if self.transactions.len() > self.delta_params.max_batch_size {
            return Err(CircuitError::BatchSizeExceeded(self.transactions.len()));
        }
        
        // Initialize aggregated delta to zeros
        let mut aggregated_delta = vec![FixedPoint32_16::from_float(0.0); dim];
        
        // Sum deltas from all transactions
        for tx in &self.transactions {
            let tx_delta = self.compute_single_delta(tx)?;
            
            for i in 0..dim {
                aggregated_delta[i] = aggregated_delta[i].add(tx_delta[i]);
            }
        }
        
        Ok(aggregated_delta)
    }
    
    /// Verify that delta can be applied homomorphically
    pub fn verify_homomorphism(
        &self,
        prev_embedding: &[FixedPoint32_16],
        delta: &[FixedPoint32_16],
        new_embedding: &[FixedPoint32_16],
    ) -> CircuitResult<FixedPoint32_16> {
        let dim = self.config.params.encoder_dim;
        let error_bound = self.config.params.homomorphism_error_bound;
        
        if prev_embedding.len() != dim || delta.len() != dim || new_embedding.len() != dim {
            return Err(CircuitError::DimensionMismatch(dim, prev_embedding.len()));
        }
        
        // Compute expected embedding: prev + delta
        let mut expected = Vec::with_capacity(dim);
        let mut max_error = FixedPoint32_16::from_float(0.0);
        
        for i in 0..dim {
            let sum = prev_embedding[i].add(delta[i]);
            let error = if sum.0 > new_embedding[i].0 {
                FixedPoint32_16(sum.0 - new_embedding[i].0)
            } else {
                FixedPoint32_16(new_embedding[i].0 - sum.0)
            };
            
            expected.push(sum);
            
            if error.0 > max_error.0 {
                max_error = error;
            }
        }
        
        // Check error bound
        if max_error.0 > error_bound.0 {
            return Err(CircuitError::HomomorphismViolation(max_error.to_float()));
        }
        
        Ok(max_error)
    }
}


impl NervCircuit for DeltaCircuit {
    fn params(&self) -> &NervCircuitParams {
        &self.config.params
    }
    
    fn public_inputs(&self) -> &CircuitPublicInputs {
        // Delta circuit doesn't have traditional public inputs
        &CircuitPublicInputs {
            previous_embedding_hash: [0u8; 32],
            new_embedding_hash: [0u8; 32],
            batch_hash: [0u8; 32],
            shard_id: 0,
            lattice_height: 0,
        }
    }
    
    fn witness(&self) -> &CircuitWitness {
        // Convert transactions to witness format
        &CircuitWitness {
            state: Vec::new(),
            transactions: self.transactions.clone(),
            encoder_weights: Vec::new(),
            previous_embedding: None,
        }
    }
    
    fn compute_embedding(&self) -> CircuitResult<Vec<FixedPoint32_16>> {
        // Delta circuit computes deltas, not embeddings
        self.compute_batch_delta()
    }
    
    fn verify_homomorphism(&self, _embedding: &[FixedPoint32_16]) -> CircuitResult<FixedPoint32_16> {
        // This method isn't applicable for Delta circuit
        Ok(FixedPoint32_16::from_float(0.0))
    }
}


impl Circuit<pallas::Base> for DeltaCircuit {
    type Config = DeltaConfig;
    type FloorPlanner = SimpleFloorPlanner;
    
    fn without_witnesses(&self) -> Self {
        Self {
            config: self.config.clone(),
            delta_params: self.delta_params.clone(),
            transactions: Vec::new(),
            _marker: PhantomData,
        }
    }
    
    fn configure(meta: &mut ConstraintSystem<pallas::Base>) -> Self::Config {
        Self::configure(meta)
    }
    
    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<pallas::Base>,
    ) -> Result<(), Error> {
        let dim = config.params.encoder_dim;
        
        // Step 1: Initialize accumulation register to zero
        let zero = Value::known(pallas::Base::zero());
        let mut accum = vec![zero; dim];
        
        // Step 2: Process each transaction
        for (tx_idx, tx) in self.transactions.iter().enumerate() {
            // Compute delta for this transaction in-circuit
            let tx_delta = self.compute_single_delta(tx)
                .map_err(|_| Error::Synthesis)?;
            
            // Convert to field elements
            let tx_delta_fields: Vec<Value<pallas::Base>> = tx_delta
                .iter()
                .map(|&fp| Value::known(pallas::Base::from(fp.0 as u64)))
                .collect();
            
            // Accumulate: accum = accum + tx_delta
            for i in 0..dim {
                accum[i] = accum[i] + tx_delta_fields[i];
            }
            
            // Constrain accumulation in the circuit
            self.constrain_delta_accumulation(
                &mut layouter,
                tx_idx,
                &tx_delta_fields,
                &accum,
            )?;
        }
        
        // Step 3: Output final accumulated delta
        self.constrain_final_delta(&mut layouter, &accum)?;
        
        Ok(())
    }
}


impl DeltaCircuit {
    /// Constrain delta accumulation in the circuit
    fn constrain_delta_accumulation(
        &self,
        layouter: &mut impl Layouter<pallas::Base>,
        tx_idx: usize,
        tx_delta: &[Value<pallas::Base>],
        accum: &[Value<pallas::Base>],
    ) -> Result<(), Error> {
        // In a real implementation, we would:
        // 1. Assign tx_delta values to delta_col
        // 2. Assign previous accum values
        // 3. Assign new accum values
        // 4. Apply batch_aggregation gate
        
        // For now, we'll just return Ok
        Ok(())
    }
    
    /// Constrain final delta output
    fn constrain_final_delta(
        &self,
        layouter: &mut impl Layouter<pallas::Base>,
        final_delta: &[Value<pallas::Base>],
    ) -> Result<(), Error> {
        // In a real implementation, we would:
        // 1. Expose final_delta as instance column
        // 2. Constrain it matches computed accumulation
        
        // For now, we'll just return Ok
        Ok(())
    }
}


/// Generate default delta parameters for testing
pub fn test_delta_params() -> DeltaParams {
    let dim = 512;
    
    // Create dummy account embeddings
    let mut account_embeddings = Vec::new();
    for i in 0..1000 {
        let mut embedding = Vec::with_capacity(dim);
        for j in 0..dim {
            let value = ((i * dim + j) as f64).sin().abs() * 2.0 - 1.0;
            embedding.push(FixedPoint32_16::from_float(value));
        }
        account_embeddings.push(embedding);
    }
    
    // Create bias terms
    let mut transfer_bias = Vec::with_capacity(dim);
    for i in 0..dim {
        let bias = (i as f64 * 0.01).sin() * 0.1;
        transfer_bias.push(FixedPoint32_16::from_float(bias));
    }
    
    DeltaParams {
        account_embeddings,
        transfer_bias,
        amount_scaling: FixedPoint32_16::from_float(1.0),
        max_batch_size: 256,
    }
}


#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_compute_single_delta() {
        let params = NervCircuitParams::default();
        
        let config = DeltaConfig {
            params: params.clone(),
            instance: Column::<Instance>::new(0, 0),
            advice: [Column::<Advice>::new(0, 0); 8],
            fixed: [Column::<Fixed>::new(0, 0); 4],
            sender_embed_col: Column::<Advice>::new(0, 0),
            receiver_embed_col: Column::<Advice>::new(0, 0),
            amount_col: Column::<Advice>::new(0, 0),
            delta_col: Column::<Advice>::new(0, 0),
        };
        
        let delta_params = test_delta_params();
        
        // Create a test transaction
        let tx = Transaction {
            sender: [1u8; 32],
            receiver: [2u8; 32],
            amount: FixedPoint32_16::from_float(100.0),
            nonce: 1,
            timestamp: 1234567890,
        };
        
        let circuit = DeltaCircuit::new(
            config,
            delta_params,
            vec![tx],
        );
        
        let delta = circuit.compute_single_delta(&circuit.transactions[0]).unwrap();
        
        assert_eq!(delta.len(), 512);
        
        // Verify delta values are within reasonable range
        for &value in &delta {
            let float_val = value.to_float();
            assert!(float_val >= -200.0 && float_val <= 200.0);
        }
    }
    
    #[test]
    fn test_compute_batch_delta() {
        let params = NervCircuitParams::default();
        
        let config = DeltaConfig {
            params: params.clone(),
            instance: Column::<Instance>::new(0, 0),
            advice: [Column::<Advice>::new(0, 0); 8],
            fixed: [Column::<Fixed>::new(0, 0); 4],
            sender_embed_col: Column::<Advice>::new(0, 0),
            receiver_embed_col: Column::<Advice>::new(0, 0),
            amount_col: Column::<Advice>::new(0, 0),
            delta_col: Column::<Advice>::new(0, 0),
        };
        
        let delta_params = test_delta_params();
        
        // Create multiple test transactions
        let transactions = vec![
            Transaction {
                sender: [1u8; 32],
                receiver: [2u8; 32],
                amount: FixedPoint32_16::from_float(100.0),
                nonce: 1,
                timestamp: 1234567890,
            },
            Transaction {
                sender: [3u8; 32],
                receiver: [4u8; 32],
                amount: FixedPoint32_16::from_float(50.0),
                nonce: 2,
                timestamp: 1234567891,
            },
        ];
        
        let circuit = DeltaCircuit::new(
            config,
            delta_params,
            transactions,
        );
        
        let batch_delta = circuit.compute_batch_delta().unwrap();
        
        assert_eq!(batch_delta.len(), 512);
        
        // Batch delta should be the sum of individual deltas
        let delta1 = circuit.compute_single_delta(&circuit.transactions[0]).unwrap();
        let delta2 = circuit.compute_single_delta(&circuit.transactions[1]).unwrap();
        
        for i in 0..512 {
            let expected = delta1[i].add(delta2[i]);
            let actual = batch_delta[i];
            
            // Allow small floating point differences
            let diff = (expected.to_float() - actual.to_float()).abs();
            assert!(diff < 0.001);
        }
    }
    
    #[test]
    fn test_verify_homomorphism() {
        let params = NervCircuitParams::default();
        
        let config = DeltaConfig {
            params: params.clone(),
            instance: Column::<Instance>::new(0, 0),
            advice: [Column::<Advice>::new(0, 0); 8],
            fixed: [Column::<Fixed>::new(0, 0); 4],
            sender_embed_col: Column::<Advice>::new(0, 0),
            receiver_embed_col: Column::<Advice>::new(0, 0),
            amount_col: Column::<Advice>::new(0, 0),
            delta_col: Column::<Advice>::new(0, 0),
        };
        
        let delta_params = test_delta_params();
        
        let circuit = DeltaCircuit::new(
            config,
            delta_params,
            Vec::new(),
        );
        
        // Create test embeddings and delta
        let dim = 512;
        let mut prev_embedding = Vec::with_capacity(dim);
        let mut delta = Vec::with_capacity(dim);
        let mut new_embedding = Vec::with_capacity(dim);
        
        for i in 0..dim {
            prev_embedding.push(FixedPoint32_16::from_float(i as f64));
            delta.push(FixedPoint32_16::from_float(1.0));
            new_embedding.push(FixedPoint32_16::from_float(i as f64 + 1.0));
        }
        
        // This should pass: new = prev + delta exactly
        let error = circuit.verify_homomorphism(
            &prev_embedding,
            &delta,
            &new_embedding,
        ).unwrap();
        
        assert!(error.to_float() < 1e-9);
        
        // Now test with an error that's too large
        let mut bad_new_embedding = new_embedding.clone();
        bad_new_embedding[0] = FixedPoint32_16::from_float(1000.0); // Large error
        
        let result = circuit.verify_homomorphism(
            &prev_embedding,
            &delta,
            &bad_new_embedding,
        );
        
        assert!(matches!(result, Err(CircuitError::HomomorphismViolation(_))));
    }
}

